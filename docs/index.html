<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <meta name="theme-color" content="#0f0f23">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="application-name" content="Journal">
  <meta name="msapplication-TileColor" content="#0f0f23">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Journal</title>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <style>
    /* CSS Variables for theming */
    :root {
      /* Dark Theme (default) */
      --bg-primary: #0f0f23;
      --bg-secondary: #1a1a2e;
      --bg-tertiary: #16213e;
      --text-primary: #ffffff;
      --text-secondary: #e2e8f0;
      --text-muted: #cbd5e1;
      --accent-primary: #a855f7;
      --accent-secondary: #6366f1;
      --accent-tertiary: #8b5cf6;
      --header-bg: rgba(15, 15, 35, 0.9);
      --border-color: rgba(255, 255, 255, 0.1);
      --input-bg: rgba(15, 15, 35, 0.8);
      --card-bg: rgba(15, 15, 35, 0.8);
      --star-color: #ffffff;
      --button-gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      --button-hover: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
    }

    /* Sky Theme */
    [data-theme="sky"] {
      --bg-primary: #e0f2fe;
      --bg-secondary: #bae6fd;
      --bg-tertiary: #7dd3fc;
      --text-primary: #0c4a6e;
      --text-secondary: #0369a1;
      --text-muted: #0ea5e9;
      --accent-primary: #0284c7;
      --accent-secondary: #0369a1;
      --accent-tertiary: #0c4a6e;
      --header-bg: rgba(224, 242, 254, 0.9);
      --border-color: rgba(12, 74, 110, 0.2);
      --input-bg: rgba(255, 255, 255, 0.8);
      --card-bg: rgba(255, 255, 255, 0.9);
      --star-color: #fbbf24;
      --button-gradient: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
      --button-hover: linear-gradient(135deg, #0369a1 0%, #0c4a6e 100%);
    }

    body {
      font-family: 'Georgia', serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(180deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
      color: var(--text-primary);
      text-align: center;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      position: relative;
      transition: all 0.3s ease;
    }
    
    /* Animated Stars Background */
    .stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    
    .star {
      position: absolute;
      background: var(--star-color);
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }
    
    .star:nth-child(1) { width: 2px; height: 2px; top: 10%; left: 20%; animation-delay: 0s; }
    .star:nth-child(2) { width: 1px; height: 1px; top: 15%; left: 80%; animation-delay: 0.5s; }
    .star:nth-child(3) { width: 3px; height: 3px; top: 25%; left: 40%; animation-delay: 1s; }
    .star:nth-child(4) { width: 1px; height: 1px; top: 35%; left: 70%; animation-delay: 1.5s; }
    .star:nth-child(5) { width: 2px; height: 2px; top: 45%; left: 10%; animation-delay: 2s; }
    .star:nth-child(6) { width: 1px; height: 1px; top: 55%; left: 90%; animation-delay: 2.5s; }
    .star:nth-child(7) { width: 3px; height: 3px; top: 65%; left: 30%; animation-delay: 0.3s; }
    .star:nth-child(8) { width: 2px; height: 2px; top: 75%; left: 60%; animation-delay: 0.8s; }
    .star:nth-child(9) { width: 1px; height: 1px; top: 85%; left: 15%; animation-delay: 1.3s; }
    .star:nth-child(10) { width: 2px; height: 2px; top: 95%; left: 85%; animation-delay: 1.8s; }
    .star:nth-child(11) { width: 1px; height: 1px; top: 5%; left: 50%; animation-delay: 0.7s; }
    .star:nth-child(12) { width: 3px; height: 3px; top: 20%; left: 5%; animation-delay: 1.2s; }
    .star:nth-child(13) { width: 2px; height: 2px; top: 30%; left: 95%; animation-delay: 1.7s; }
    .star:nth-child(14) { width: 1px; height: 1px; top: 50%; left: 25%; animation-delay: 0.2s; }
    .star:nth-child(15) { width: 2px; height: 2px; top: 60%; left: 75%; animation-delay: 0.9s; }
    .star:nth-child(16) { width: 3px; height: 3px; top: 70%; left: 45%; animation-delay: 1.4s; }
    .star:nth-child(17) { width: 1px; height: 1px; top: 80%; left: 35%; animation-delay: 1.9s; }
    .star:nth-child(18) { width: 2px; height: 2px; top: 90%; left: 65%; animation-delay: 0.4s; }
    .star:nth-child(19) { width: 1px; height: 1px; top: 12%; left: 55%; animation-delay: 0.6s; }
    .star:nth-child(20) { width: 3px; height: 3px; top: 22%; left: 85%; animation-delay: 1.1s; }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    /* Moving stars */
    .moving-star {
      position: absolute;
      background: var(--star-color);
      border-radius: 50%;
      animation: moveStar 8s linear infinite;
    }
    
    .moving-star:nth-child(21) { width: 1px; height: 1px; top: 0%; left: 0%; animation-duration: 12s; }
    .moving-star:nth-child(22) { width: 2px; height: 2px; top: 20%; left: 100%; animation-duration: 15s; animation-delay: 2s; }
    .moving-star:nth-child(23) { width: 1px; height: 1px; top: 40%; left: 0%; animation-duration: 10s; animation-delay: 4s; }
    .moving-star:nth-child(24) { width: 3px; height: 3px; top: 60%; left: 100%; animation-duration: 18s; animation-delay: 1s; }
    .moving-star:nth-child(25) { width: 2px; height: 2px; top: 80%; left: 0%; animation-duration: 14s; animation-delay: 3s; }
    
    @keyframes moveStar {
      0% { transform: translateX(-100px) translateY(0px); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateX(calc(100vw + 100px)) translateY(-50px); opacity: 0; }
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--header-bg);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border-color);
      z-index: 10;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    }
    
    .content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 80px 15px 20px 15px;
      position: relative;
      z-index: 1;
    }
    .prompt, h2, p {
      margin: 10px 0;
    }
    h2 {
      font-size: 1.6rem;
      font-weight: 400;
      color: var(--accent-primary);
      letter-spacing: 0.5px;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
    }
    .prompt {
      font-size: 1.1rem;
      font-style: italic;
      color: var(--text-secondary);
    }
    p {
      font-size: 0.95rem;
      color: var(--text-muted);
    }
    .button {
      background: var(--button-gradient);
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: 'Georgia', serif;
      font-weight: 400;
      letter-spacing: 1px;
      box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);
      transition: all 0.3s ease-in-out;
    }
    .button:hover {
      background: var(--button-hover);
      color: #ffffff;
      box-shadow: 0 6px 14px rgba(99, 102, 241, 0.4), 0 0 30px rgba(139, 92, 246, 0.3);
      transform: translateY(-2px);
    }
    .button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .button:disabled {
      background: #ccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    .loading {
      position: relative;
      pointer-events: none;
    }
    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid transparent;
      border-top: 2px solid #ffffff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .floating-plus {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 56px;
      height: 56px;
      background: var(--button-gradient);
      color: #ffffff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);
      transition: all 0.3s ease-in-out;
      z-index: 1000;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .floating-plus:hover {
      background: var(--button-hover);
      color: #ffffff;
      box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4), 0 0 25px rgba(139, 92, 246, 0.3);
      transform: translateY(-2px) scale(1.03);
    }
    .floating-plus:active {
      transform: translateY(-1px) scale(1.01);
    }
    .hidden { 
      display: none; 
    }
    
    /* Elegant screen transitions */
    .screen-transition {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .fade-out {
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.2s ease-out;
    }
    
    .fade-in {
      opacity: 1;
      transform: translateY(0);
      transition: all 0.3s ease-out;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 99999;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      pointer-events: none;
      width: 100vw;
      height: 100vh;
      background-color: var(--bg-primary) !important;
    }
    
    .loading-overlay.active {
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: all !important;
      display: flex !important;
    }
    
    /* Prevent white flash during transitions */
    body.transitioning {
      overflow: hidden;
    }
    
    .screen-container {
      position: relative;
      min-height: 100vh;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .loading-text {
      margin-top: 20px;
      color: var(--text-secondary);
      font-size: 1rem;
      font-weight: 300;
    }
    input[type="text"], input[type="email"], input[type="password"], textarea {
      width: 90%;
      padding: 12px;
      font-size: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin: 10px 0;
      font-family: 'Georgia', serif;
      background: var(--input-bg);
      color: var(--text-primary);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 10px rgba(139, 92, 246, 0.1);
    }
    textarea { min-height: 130px; resize: vertical; }
    #history-list { width: 95%; }
    .history-item {
      text-align: left;
      padding: 15px;
      background: var(--card-bg);
      margin: 8px 0;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 15px rgba(139, 92, 246, 0.1);
      cursor: pointer;
      border: 1px solid var(--border-color);
    }
    .history-item img {
      max-width: 100%;
      border-radius: 12px;
      margin-top: 10px;
    }
    .history-item button {
      margin: 4px;
      padding: 6px 14px;
      font-size: 0.85rem;
      border-radius: 20px;
      background: var(--button-gradient);
      color: #ffffff;
      box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3);
      transition: all 0.3s ease-in-out;
    }
    .history-item button:hover {
      background: var(--button-hover);
      color: #ffffff;
      box-shadow: 0 4px 10px rgba(99, 102, 241, 0.4);
      transform: translateY(-1px);
    }
    img.preview {
      max-width: 90%;
      max-height: 300px;
      margin-top: 10px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      object-fit: cover;
    }
    
    .history-item img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      margin: 10px 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      object-fit: cover;
    }
    #current-date {
      font-size: 1.1rem;
      font-weight: 400;
      color: var(--accent-primary);
      margin-bottom: 6px;
      letter-spacing: 0.5px;
    }
    #current-time {
      font-size: 0.9rem;
      font-weight: 300;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }
    .button-group {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 10px 0;
      flex-wrap: wrap;
    }




    @media (max-width: 480px) {
      h2 { font-size: 1.4rem; }
      .prompt { font-size: 1rem; }
      p { font-size: 0.9rem; }
      .button { font-size: 0.85rem; padding: 8px 16px; }
      input[type="text"], input[type="email"], input[type="password"], textarea { width: 92%; padding: 10px; }
      .history-item { padding: 12px; }
      .floating-plus { width: 52px; height: 52px; font-size: 26px; }
      .options-menu { min-width: 170px; padding: 10px; }
      .options-menu button { padding: 10px 14px; font-size: 0.95rem; min-height: 38px; }
      
      /* Mobile header adjustments */
      .header { padding: 10px 16px; }
      
      /* Mobile toolbar */
      .photo-toolbar {
        flex-wrap: wrap;
        gap: 6px !important;
        padding: 10px !important;
      }
      
      .toolbar-button {
        padding: 8px 12px !important;
        font-size: 0.8rem !important;
        border-radius: 25px !important;
        min-width: 60px !important;
      }
    }
    
    /* Toolbar button hover effects */
    .toolbar-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 15px rgba(99, 102, 241, 0.4), 0 0 25px rgba(139, 92, 246, 0.3);
    }
    
    .toolbar-button:active {
      transform: scale(0.95);
    }
    
    .toolbar-button:disabled {
      background: var(--bg-secondary) !important;
      color: var(--text-muted) !important;
      cursor: not-allowed !important;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
    }
    .options-menu {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: transparent;
      padding: 12px;
      display: none;
      z-index: 999;
      min-width: 180px;
    }
    .options-menu button {
      display: block;
      width: 100%;
      margin: 6px 0;
      background: var(--button-gradient);
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease-in-out;
      font-size: 0.9rem;
      font-weight: 500;
      text-align: center;
      min-height: 42px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }
    .options-menu button:hover {
      background: var(--button-hover);
      color: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }
    .options-menu button:active {
      transform: translateY(0);
    }

    /* Google Sign In Button Styling */
    .google-signin-btn {
      background: #4285f4 !important;
      border: 1px solid #4285f4 !important;
      color: white !important;
      font-weight: 500;
      transition: all 0.3s ease-in-out;
    }

    .google-signin-btn:hover {
      background: #3367d6 !important;
      border-color: #3367d6 !important;
      color: white !important;
      box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
      transform: translateY(-1px);
    }

    .google-signin-btn:active {
      background: #2c5aa0 !important;
      transform: translateY(0);
    }

    .google-signin-btn svg {
      flex-shrink: 0;
    }

    /* Apple Sign In Button Styling */
    .apple-signin-btn {
      background: #000000 !important;
      border: 1px solid #000000 !important;
      color: white !important;
      font-weight: 500;
      transition: all 0.3s ease-in-out;
    }

    .apple-signin-btn:hover {
      background: #333333 !important;
      border-color: #333333 !important;
      color: white !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transform: translateY(-1px);
    }

    .apple-signin-btn:active {
      background: #1a1a1a !important;
      transform: translateY(0);
    }

    .apple-signin-btn svg {
      flex-shrink: 0;
    }

    /* Sun for sky theme */
    .sun {
      position: fixed;
      top: 25%;
      right: 8%;
      width: 40px;
      height: 40px;
      background: radial-gradient(circle, #fbbf24 0%, #f59e0b 100%);
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
      z-index: 1;
      animation: sunGlow 4s ease-in-out infinite alternate;
    }

    @keyframes sunGlow {
      0% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
      100% { box-shadow: 0 0 35px rgba(251, 191, 36, 0.6); }
    }






  </style>
</head>
<body>
  <!-- Animated Stars Background -->
  <div class="stars">
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="moving-star"></div>
    <div class="moving-star"></div>
    <div class="moving-star"></div>
    <div class="moving-star"></div>
    <div class="moving-star"></div>
  </div>
  

  
  <!-- Sun for Sky Theme -->
  <div class="sun" style="display: none;"></div>
  
  <!-- Elegant Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay" style="opacity: 0; visibility: hidden;">
    <div style="text-align: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">Signing in...</div>
    </div>
  </div>
  
  <div class="header">
    <div>
      <button id="theme-toggle" class="button" onclick="toggleTheme()" style="margin-right: 10px; padding: 8px 12px; font-size: 0.8rem;">🌙</button>
      <!-- Authentication removed - automatic sync without signup -->
    </div>
    <div>
      <button id="sign-out-btn" class="button" onclick="handleSignOut()" style="background: var(--accent-secondary); padding: 8px 12px; font-size: 0.8rem; display: none;">Sign Out</button>
    </div>
  </div>
  

  <!-- Authentication Screen -->
  <div id="auth-screen" class="content screen-transition">
    <h2>My Spiritual Journey</h2>
    
    <!-- Firebase Auth Options -->
    <div style="text-align: center; margin-top: 30px;">
      <!-- Google Sign In Button -->
      <button class="button firebase-google-btn" onclick="signInWithGoogle()" style="background: #4285f4; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 0.9rem; padding: 10px 20px; margin: 0 auto; border-radius: 20px; font-weight: 500; box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3); transition: all 0.2s ease;">
        <svg width="18" height="18" viewBox="0 0 24 24">
          <path fill="white" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
          <path fill="white" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
          <path fill="white" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
          <path fill="white" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
        </svg>
        Continue with Google
      </button>
      
      <p style="font-size: 0.9rem; color: var(--text-muted); margin: 20px 0;">One-click sign-in with your Google account</p>
      
      
    </div>
    
    <div id="auth-message" class="prompt" style="display: none; margin-top: 15px;"></div>
  </div>

  <!-- Main Screen -->
  <div id="main-screen" class="content hidden screen-transition">
    <button id="back-to-inspire-btn" class="button" onclick="goBackToInspire()" style="display: none; margin-bottom: 20px;">← Back to Inspire Me</button>
    <div id="welcome-message" class="prompt" style="display: none; margin-bottom: 20px;"></div>
    <div id="quota-status" class="prompt" style="display: none; margin-bottom: 20px; font-size: 0.9rem; color: var(--text-muted);"></div>
    <div id="quote" class="prompt">Loading inspiration...</div>
    <button class="button" onclick="newQuote()">Inspire Me</button>
          <h2>My Spiritual Journey</h2>
      <p>Tap the plus button to start your journey</p>
  </div>
  <!-- Authentication screens removed - no signup/login required -->
  <!-- Entry Screen -->
  <div id="entry-screen" class="content hidden">
    <h2 id="entry-date"></h2>
    <div id="reflection-question" class="prompt">What moment today felt like a gift from the universe?</div>
    <input type="text" id="title" placeholder="Title">
    <textarea id="reflection" placeholder="Speak or type your reflections..."></textarea>
    <div>
      <div class="photo-toolbar" style="display: flex; gap: 8px; margin: 15px 0; padding: 12px; background: transparent; justify-content: center; align-items: center;">
        <button type="button" class="toolbar-button" onclick="newQuestion()" style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          New
        </button>
        <label for="image-input" class="toolbar-button" style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          Photos
      </label>
        <label for="camera-input" class="toolbar-button" style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          Camera
        </label>
        <button type="button" class="toolbar-button" onclick="startVoiceRecognition()" style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          Voice
        </button>
        <button type="button" class="toolbar-button" id="save" disabled style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: not-allowed; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          Save
        </button>
        <button type="button" class="toolbar-button" onclick="goBack()" style="display: flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 25px; background: var(--button-gradient); color: #ffffff; border: none; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; font-weight: 400; white-space: nowrap; box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);">
          Back
        </button>
      </div>
      <input type="file" 
             accept="image/*,image/jpeg,image/jpg,image/png,image/gif,image/webp,image/heic,image/heif" 
             id="image-input" 
             multiple="false"
             style="display: none;"
             webkitdirectory="false"
             directory="false"
             x-moz-errormessage=""
             data-capture="none"
             data-testid="photos-input">
      <input type="file" 
             accept="image/*" 
             id="camera-input" 
             capture="environment" 
             multiple="false"
             style="display: none;"
             webkitdirectory="false"
             directory="false">
      <div id="image-preview-container" style="display: none;">
        <div id="image-loading" style="display: none; text-align: center; padding: 20px; color: var(--text-muted);">
          📸 Loading image...
        </div>
        <img id="preview-image" class="preview" src="" alt="Preview">
        <button type="button" class="button" onclick="removeImage()" style="margin-top: 10px;">Remove Photo</button>
      </div>
    </div>
  </div>
  <!-- History Screen -->
  <div id="history-screen" class="content hidden">
    <h2>Past Reflections</h2>
    <div id="history-list"></div>
    <div class="button-group">
      <button class="button" onclick="goBack()">Back</button>
    </div>
  </div>
  <div class="floating-plus" onclick="toggleOptionsMenu()">+</div>
  <div id="options-menu" class="options-menu">
          <button id="start-journaling-btn" onclick="showEntryScreen()" style="display: none;">Start Journaling</button>
          <button id="past-reflections-btn" onclick="showHistory()" style="display: none;">Past Reflections</button>
          <button id="home-btn" onclick="goToHome()" style="display: none;">Home</button>
  </div>
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCBKWKwZq8XqECABmuPn5vZ3D8O3hz8Ts0",
      authDomain: "spiritual-journey-e3330.firebaseapp.com",
      projectId: "spiritual-journey-e3330",
      storageBucket: "spiritual-journey-e3330.firebasestorage.app",
      messagingSenderId: "443749946566",
      appId: "1:443749946566:web:b19c90120ed09bb128f3c7",
      measurementId: "G-QFCNBZL9G9"
    };

    // Initialize Firebase
    let firebase;
    let auth;
    let db;
    
    function initializeFirebase() {
      try {
        // Check if Firebase is available
        if (typeof window.firebase === 'undefined') {
          console.error('Firebase library not loaded yet');
          return false;
        }
        
        // Initialize Firebase
        firebase = window.firebase;
        
        // Check if already initialized
        if (firebase.apps.length === 0) {
        firebase.initializeApp(firebaseConfig);
        }
        
        // Initialize Firebase Auth and Firestore
        auth = firebase.auth();
        db = firebase.firestore();
        
        console.log('Firebase initialized successfully');
        return true;
      } catch (error) {
        console.error('Firebase initialization error:', error);
        return false;
      }
    }
    

    let recognition;
    let reflections = [];
    let currentImage = "";
    let editingIndex = null;
    let user = null;
    let currentTheme = 'dark'; // Default theme

    // Backup reflections to a secondary key with timestamp
    function backupReflections() {
      try {
        const payload = {
          reflections,
          backedUpAt: new Date().toISOString()
        };
        localStorage.setItem('reflections_backup', JSON.stringify(payload));
      } catch (e) {
        console.warn('Backup failed:', e);
      }
    }

    // Smart image management system
    function createImageBackups() {
      try {
        const imageBackups = {};
        let backupCount = 0;
        
        // Create separate image backups for each reflection with images
        reflections.forEach((reflection, index) => {
          if (reflection.image && reflection.image.length > 0) {
            const imageKey = `image_backup_${index}_${reflection.title?.replace(/[^a-zA-Z0-9]/g, '_') || 'untitled'}`;
            try {
              localStorage.setItem(imageKey, reflection.image);
              imageBackups[index] = imageKey;
              backupCount++;
            } catch (e) {
              console.warn(`Failed to backup image for reflection ${index}:`, e);
            }
          }
        });
        
        // Store image backup mapping
        if (backupCount > 0) {
          localStorage.setItem('image_backup_mapping', JSON.stringify(imageBackups));
          console.log(`Created ${backupCount} image backups`);
        }
        
        return backupCount;
      } catch (e) {
        console.error('Failed to create image backups:', e);
        return 0;
      }
    }

    function restoreImagesFromBackups() {
      try {
        const mapping = localStorage.getItem('image_backup_mapping');
        if (!mapping) return 0;
        
        const imageBackups = JSON.parse(mapping);
        let restoredCount = 0;
        
        Object.entries(imageBackups).forEach(([index, imageKey]) => {
          const imageData = localStorage.getItem(imageKey);
          if (imageData && reflections[index]) {
            reflections[index].image = imageData;
            restoredCount++;
          }
        });
        
        if (restoredCount > 0) {
          console.log(`Restored ${restoredCount} images from backups`);
        }
        
        return restoredCount;
      } catch (e) {
        console.error('Failed to restore images from backups:', e);
        return 0;
      }
    }

    // Comprehensive data protection system
    function createMultipleBackups() {
      try {
        const timestamp = Date.now();
        const backupData = {
          timestamp: timestamp,
          reflections: reflections,
          totalCount: reflections.length,
          version: '2.0'
        };
        
        // Create multiple backup keys with different strategies
        const backupKeys = [
          'reflections_backup_1',    // Primary backup
          'reflections_backup_2',    // Secondary backup
          `reflections_backup_${timestamp}`, // Timestamped backup
          'reflections_emergency'    // Emergency backup
        ];
        
        let successCount = 0;
        backupKeys.forEach(key => {
          try {
            localStorage.setItem(key, JSON.stringify(backupData));
            successCount++;
          } catch (e) {
            console.warn(`Failed to create backup ${key}:`, e);
          }
        });
        
        // Also create image backups
        const imageBackupCount = createImageBackups();
        
        console.log(`Created ${successCount}/${backupKeys.length} backups and ${imageBackupCount} image backups`);
        return successCount > 0;
      } catch (e) {
        console.error('Failed to create backups:', e);
        return false;
      }
    }

    // Safely persist reflections to localStorage with comprehensive protection
    function saveReflectionsToLocalStorageSafely(protectIndex = null) {
      // Always create backups before any save operation
      createMultipleBackups();
      
      try {
        localStorage.setItem('reflections', JSON.stringify(reflections));
        return true;
      } catch (e) {
        const isQuota = e && (e.name === 'QuotaExceededError' || e.code === 22 || String(e).toLowerCase().includes('quota'));
        if (!isQuota) return false;
        
        console.warn('localStorage quota exceeded, implementing data protection strategy...');
        
        // Strategy 1: Compress images instead of removing them
        if (Array.isArray(reflections)) {
          let imagesCompressed = 0;
          for (let i = 0; i < reflections.length; i++) {
            if (reflections[i] && reflections[i].image && reflections[i].image.length > 100000) { // Only compress large images (>100KB)
              try {
                // Compress image by reducing quality
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                  // Reduce size by 50%
                  canvas.width = img.width * 0.5;
                  canvas.height = img.height * 0.5;
                  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                  
                  // Convert to lower quality JPEG
                  const compressedImage = canvas.toDataURL('image/jpeg', 0.7);
                  reflections[i].image = compressedImage;
                  imagesCompressed++;
                  console.log(`Compressed large image for reflection ${i}: ${reflections[i].title}`);
                };
                
                img.src = reflections[i].image;
              } catch (e) {
                console.warn(`Failed to compress image for reflection ${i}:`, e);
              }
            }
          }
          console.log(`Compressed ${imagesCompressed} large images`);
        }
        
        try {
          localStorage.setItem('reflections', JSON.stringify(reflections));
          console.log('Successfully saved after stripping old images');
          return true;
        } catch (e2) {
          console.warn('Still quota exceeded, implementing emergency compression...');
          
          // Strategy 2: Compress text content (remove extra whitespace, shorten long content)
          if (Array.isArray(reflections)) {
            reflections.forEach((reflection, index) => {
              if (reflection.reflection && reflection.reflection.length > 1000) {
                // Truncate very long reflections to 1000 characters
                reflection.reflection = reflection.reflection.substring(0, 1000) + '... [truncated]';
                console.log(`Compressed long reflection ${index}: ${reflection.title}`);
              }
            });
          }
          
          try {
            localStorage.setItem('reflections', JSON.stringify(reflections));
            console.log('Successfully saved after compression');
        return true;
          } catch (e3) {
            console.error('Emergency: Storage still full after all optimizations');
            
            // Strategy 3: Last resort - keep only essential data
            const emergencyReflections = reflections.map(reflection => ({
              title: reflection.title || 'Untitled',
              reflection: reflection.reflection ? reflection.reflection.substring(0, 500) : '',
              date: reflection.date || reflection.createdAt || new Date().toISOString(),
              // Remove image, createdAt, and other non-essential fields
            }));
            
            try {
              localStorage.setItem('reflections', JSON.stringify(emergencyReflections));
              console.log('Saved emergency compressed version');
              
              // Update the main reflections array to match
              reflections.length = 0;
              reflections.push(...emergencyReflections);
              
              alert(`⚠️ Storage Emergency\n\nYour storage is critically full. I've saved your journals in compressed format to prevent data loss.\n\n• All images removed\n• Long text truncated\n• All journals preserved\n\nPlease export your data and consider signing in to sync to cloud storage.`);
              return true;
            } catch (e4) {
              console.error('CRITICAL: Unable to save even emergency version');
              alert(`🚨 CRITICAL STORAGE ERROR\n\nUnable to save your journals due to storage limits.\n\nYour data is backed up in multiple locations. Please:\n1. Export your journals immediately\n2. Clear browser cache\n3. Sign in to sync to cloud storage\n\nYour journals are NOT lost - they're in the backups!`);
        return false;
            }
          }
        }
      }
    }

    const originalQuotes = [
      "The wound is the place where the light enters you. – Rumi",
      "We should write because humans are spiritual beings and writing is a powerful form of prayer and meditation. – Gloria Anzaldúa",
      "Fill your paper with the breathings of your heart. – William Wordsworth",
      "There is no way to happiness—happiness is the way. – Thich Nhat Hanh",
      "The present moment is filled with joy and happiness. If you are attentive, you will see it. – Thich Nhat Hanh",
      "Breathing in, I calm my body. Breathing out, I smile. Dwelling in the present moment, I know this is a wonderful moment. – Thich Nhat Hanh",
      "You do not need to know precisely what is happening, or exactly where it is all going. What you need is to recognize the possibilities and challenges offered by the present moment, and to embrace them with courage, faith, and hope. – Thomas Merton",
      "Happiness is not a matter of intensity but of balance, order, rhythm and harmony. – Thomas Merton",
      "Compassion is a verb. – Thich Nhat Hanh",
      "When another person makes you suffer, it is because he suffers deeply within himself. He does not need punishment; he needs help. – Thich Nhat Hanh",
      "Understanding is love's other name. If you don't understand, you cannot love. – Thich Nhat Hanh",
      "Love is our true destiny. We do not find the meaning of life by ourselves alone—we find it with another. – Thomas Merton",
      "The biggest human temptation is to settle for too little love. – Thomas Merton",
      "Our job is to love others without stopping to inquire whether or not they are worthy. – Thomas Merton",
      "Sometimes your joy is the source of your smile, but sometimes your smile can be the source of your joy. – Thich Nhat Hanh",
      "Walk as if you are kissing the Earth with your feet. – Thich Nhat Hanh",
      "Because you are alive, everything is possible. – Thich Nhat Hanh",
      "We are not at peace because we have not yet learned to be alone with ourselves. – Thomas Merton",
      "Silence is the language of God, all else is poor translation. – Thomas Merton",
      "The things we fear most in prayer are the things that can save us. – Thomas Merton",
      "In the stillness of your soul, wisdom whispers its truths. – Unknown",
      "Every step you take is a dance with the universe's rhythm. – Unknown",
      "The heart's quiet moments hold the seeds of transformation. – Unknown",
      "Embrace the shadows, for they guide you to your light. – Unknown",
      "Your spirit blooms where gratitude takes root. – Unknown",
      "Do small things with great love. — St. Teresa of Calcutta",
      "Where there is love, there is life. — Mahatma Gandhi",
      "Kindness is the language which the deaf can hear and the blind can see. — Mark Twain",
      "Joy is the simplest form of gratitude. — Karl Barth",
      "Give thanks in all circumstances. — 1 Thessalonians 5:18",
      "Come to me, all you who are weary and burdened, and I will give you rest. — Matthew 11:28",
      "Do not be afraid, for I am with you always. — Matthew 28:20",
      "Pray as though everything depended on God. Work as though everything depended on you. — St. Augustine",
      "Lord, make me an instrument of your peace. — St. Francis of Assisi",
      "Peace begins with a smile. — St. Teresa of Calcutta",
      "Kind words can be short and easy to speak, but their echoes are truly endless. — St. Teresa of Calcutta",
      "Every morning we are born again. What we do today is what matters most. — Buddha",
      "The Lord is my shepherd; I shall not want. — Psalm 23:1",
      "Those who hope in the Lord will renew their strength. They will soar on wings like eagles. — Isaiah 40:31",
      "The Lord will fight for you; you need only to be still. — Exodus 14:14",
      "Rejoice always, pray without ceasing, give thanks in all circumstances. — 1 Thessalonians 5:16–18",
      "The fruit of the Spirit is love, joy, peace, patience, kindness, generosity, faithfulness, gentleness, and self-control. — Galatians 5:22–23",
      "You learn to speak by speaking, to study by studying, to run by running, to work by working; and just so, you learn to love by loving. — St. Francis de Sales",
      "Holiness consists simply in doing God’s will, and being just what God wants us to be. — St. Thérèse of Lisieux",
      "Joy is prayer; joy is strength; joy is love; joy is a net of love by which you can catch souls. — St. Teresa of Calcutta",
      "A gentle word, a kind look, a good-natured smile can work wonders and accomplish miracles. — William Hazlitt"
    ];

    // Shuffle quotes array using Fisher-Yates algorithm
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Create shuffled quotes array
    const quotes = shuffleArray(originalQuotes);
    
    // Set initial quote immediately after quotes array is created
    let lastQuoteIndex = 0;
    if (document.getElementById('quote')) {
      document.getElementById('quote').textContent = quotes[0];
    }
    
    const originalJournalQuestions = [
      "What moment today felt like a gift from the universe?",
      "How did you find peace in a challenging situation?",
      "What inspires your soul to create today?",
      "What is one thing you're grateful for right now?",
      "What vision for your future feels most alive?"
    ];

    // Create shuffled journal questions array
    const journalQuestions = shuffleArray(originalJournalQuestions);

    function getRandomQuestion() {
      return journalQuestions[Math.floor(Math.random() * journalQuestions.length)];
    }


    function newQuote() {
      let randomIndex;
      
      // Ensure we don't show the same quote twice in a row
      do {
        randomIndex = Math.floor(Math.random() * quotes.length);
      } while (randomIndex === lastQuoteIndex && quotes.length > 1);
      
      lastQuoteIndex = randomIndex;
      document.getElementById('quote').textContent = quotes[randomIndex];
    }

    function newQuestion() {
      document.getElementById('reflection-question').textContent = getRandomQuestion();
    }

    function updateDateTime() {
      const now = new Date();
      
      // Format date for header - minimalist format
      const dateOptions = {
        month: 'short', 
        day: 'numeric'
      };
      const formattedDate = now.toLocaleDateString('en-US', dateOptions);
      document.getElementById('current-date').textContent = formattedDate;
      
      // Format time for header - clean format
      const timeOptions = { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: true 
      };
      const formattedTime = now.toLocaleTimeString('en-US', timeOptions);
      document.getElementById('current-time').textContent = formattedTime;
      
      // Format date and time for entry screen
      const entryDateElement = document.getElementById('entry-date');
      if (entryDateElement) {
        const entryOptions = {
          weekday: 'long', 
          month: 'long', 
          day: 'numeric',
          year: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit', 
          hour12: true
        };
        entryDateElement.textContent = now.toLocaleString('en-US', entryOptions);
      }
    }

    // Authentication management
    let currentUser = null;

    // Show login form
    function showLoginForm() {
      document.getElementById('login-form').style.display = 'block';
      document.getElementById('signup-form').style.display = 'none';
      document.getElementById('auth-message').style.display = 'none';
    }

    // Show signup form
    function showSignupForm() {
      document.getElementById('login-form').style.display = 'none';
      document.getElementById('signup-form').style.display = 'block';
      document.getElementById('auth-message').style.display = 'none';
    }

    // Show auth screen
    function showAuthScreen() {
      document.getElementById('auth-screen').classList.remove('hidden');
      document.getElementById('main-screen').classList.add('hidden');
      document.getElementById('entry-screen').classList.add('hidden');
      document.getElementById('history-screen').classList.add('hidden');
      
      // Hide sign out button in header
      document.getElementById('sign-out-btn').style.display = 'none';
      
      // Hide options menu buttons when not signed in
      document.getElementById('start-journaling-btn').style.display = 'none';
      document.getElementById('past-reflections-btn').style.display = 'none';
      document.getElementById('home-btn').style.display = 'none';
      
      showLoginForm();
    }

    function showMainScreen() {
      document.getElementById('auth-screen').classList.add('hidden');
      document.getElementById('main-screen').classList.remove('hidden');
      document.getElementById('entry-screen').classList.add('hidden');
      document.getElementById('history-screen').classList.add('hidden');
      
      // Show sign out button in header
      document.getElementById('sign-out-btn').style.display = 'block';
      
      // Show options menu buttons when signed in
      document.getElementById('start-journaling-btn').style.display = 'block';
      document.getElementById('past-reflections-btn').style.display = 'block';
      document.getElementById('home-btn').style.display = 'block';
    }

    // Handle user signup
    async function handleSignup() {
      const message = document.getElementById('auth-message');
      message.textContent = 'Email/password signup is not available. Please use Google Sign-In instead.';
        message.style.display = 'block';
      message.style.color = '#ff6b6b';
    }

    // Handle user login
    async function handleLogin() {
      const message = document.getElementById('auth-message');
      message.textContent = 'Email/password login is not available. Please use Google Sign-In instead.';
        message.style.display = 'block';
      message.style.color = '#ff6b6b';
    }

    // Handle forgot password
    async function handleForgotPassword() {
      const message = document.getElementById('auth-message');
      message.textContent = 'Password reset is not available. Please use Google Sign-In instead.';
        message.style.display = 'block';
      message.style.color = '#ff6b6b';
    }

    // OAuth functions removed - focusing on working authentication methods

    // Simple local storage authentication - no configuration needed

    function showCloudOptions() {
      document.getElementById('cloud-options').style.display = 'block';
    }

    function hideCloudOptions() {
      document.getElementById('cloud-options').style.display = 'none';
    }

    // Elegant transition functions - NO WHITE FLASHES
    function showLoadingOverlay(text = 'Loading...') {
      const overlay = document.getElementById('loading-overlay');
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = text;
      
      // Immediately show overlay to prevent any white flash
      overlay.style.opacity = '1';
      overlay.style.visibility = 'visible';
      overlay.style.pointerEvents = 'all';
      overlay.style.display = 'flex';
      overlay.style.zIndex = '99999';
      overlay.classList.add('active');
      
      // Prevent body scrolling during transition
      document.body.classList.add('transitioning');
    }
    
    function hideLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      
      // Reset body scrolling
      document.body.classList.remove('transitioning');
      
      // Fade out the overlay slowly to ensure smooth transition
      overlay.style.opacity = '0';
      overlay.style.visibility = 'hidden';
      overlay.style.pointerEvents = 'none';
      
      // Remove active class after fade
      setTimeout(() => {
        overlay.classList.remove('active');
      }, 200);
    }
    
    function instantScreenChange(fromScreen, toScreen, callback) {
      const from = document.getElementById(fromScreen);
      const to = document.getElementById(toScreen);
      
      // Instantly hide current screen and show new screen
      from.classList.add('hidden');
      to.classList.remove('hidden');
      
      // Show/hide sign out button based on screen
      if (toScreen === 'main-screen') {
        document.getElementById('sign-out-btn').style.display = 'block';
      } else if (toScreen === 'auth-screen') {
        document.getElementById('sign-out-btn').style.display = 'none';
      }
      
      // Execute callback if provided
      if (callback) callback();
      
      // Hide loading overlay after a longer delay to ensure everything is ready
      setTimeout(() => {
        hideLoadingOverlay();
      }, 1000); // 1 second delay to ensure no white page
    }

    // Firebase Google Sign-In - SIMPLE APPROACH
    async function signInWithGoogle() {
      const message = document.getElementById('auth-message');
      
      try {
        // Check if Firebase is initialized
        if (!firebase || !auth) {
          message.textContent = 'Firebase is loading... Please wait a moment and try again.';
          message.style.display = 'block';
          message.style.color = '#ff6b6b';
          console.error('Firebase not initialized:', { firebase: !!firebase, auth: !!auth });
          
          // Try to reinitialize Firebase
          setTimeout(async () => {
            if (initializeFirebase()) {
              message.textContent = 'Firebase loaded! You can now sign in.';
              message.style.color = '#4CAF50';
              setTimeout(() => {
                message.style.display = 'none';
              }, 2000);
            }
          }, 2000);
          return;
        }
        
        // Sign in with Google - try popup first, fallback to redirect if needed
        const provider = new firebase.auth.GoogleAuthProvider();
        let result;
        
        try {
          // Try popup first (preferred for better UX)
          result = await auth.signInWithPopup(provider);
        } catch (popupError) {
          // If popup fails due to sessionStorage issues, try redirect
          if (popupError.message.includes('sessionStorage') || 
              popupError.message.includes('Unable to process request') ||
              popupError.message.includes('missing initial state')) {
            console.log('Popup failed due to sessionStorage, trying redirect...');
            await auth.signInWithRedirect(provider);
            return; // Redirect will handle the rest
          } else {
            throw popupError; // Re-throw other errors
          }
        }
        
        // User signed in successfully
        currentUser = {
          id: result.user.uid,
          email: result.user.email,
          name: result.user.displayName,
          photoURL: result.user.photoURL,
          isFirebase: true
        };
        
        // Load reflections in background
        await loadReflections();
        
        // Simple instant screen change - no loading overlay
        document.getElementById('auth-screen').classList.add('hidden');
        document.getElementById('main-screen').classList.remove('hidden');
        
      } catch (error) {
        console.error('Google sign-in error:', error);
        
        // Provide more specific error messages
        let errorMessage = 'Sign-in error: ';
        if (error.code === 'auth/popup-closed-by-user') {
          errorMessage += 'Sign-in was cancelled. Please try again.';
        } else if (error.code === 'auth/popup-blocked') {
          errorMessage += 'Popup was blocked. Please allow popups and try again.';
        } else if (error.code === 'auth/unauthorized-domain') {
          errorMessage += 'Domain not authorized. Please add localhost to Firebase authorized domains.';
        } else if (error.code === 'auth/operation-not-allowed') {
          errorMessage += 'Google sign-in not enabled. Please enable it in Firebase console.';
        } else if (error.message.includes('sessionStorage') || 
                   error.message.includes('Unable to process request') ||
                   error.message.includes('missing initial state')) {
          errorMessage += 'Browser storage issue. Please try refreshing the page or use a different browser.';
        } else {
          errorMessage += error.message;
        }
        
        message.textContent = errorMessage;
        message.style.display = 'block';
        message.style.color = '#ff6b6b';
      }
    }

    function debugFirebase() {
      const debugInfo = `🔍 Firebase Debug Info:

Firebase SDK: ${typeof window.firebase !== 'undefined' ? '✅ Loaded' : '❌ Not loaded'}
Firebase App: ${typeof firebase !== 'undefined' ? '✅ Initialized' : '❌ Not initialized'}
Firebase Auth: ${typeof auth !== 'undefined' ? '✅ Available' : '❌ Not available'}
Firebase DB: ${typeof db !== 'undefined' ? '✅ Available' : '❌ Not available'}

Current URL: ${window.location.href}
User Agent: ${navigator.userAgent}

Console Errors: Check browser console (F12) for detailed errors

Next Steps:
1. If Firebase SDK not loaded: Check internet connection
2. If Firebase not initialized: Refresh the page
3. If Auth not available: Check Firebase config
4. Check browser console for detailed error messages`;
      
      alert(debugInfo);
      console.log('Firebase Debug:', {
        firebaseSDK: typeof window.firebase,
        firebase: typeof firebase,
        auth: typeof auth,
        db: typeof db,
        config: firebaseConfig
      });
    }

    async function debugFirebaseData() {
      if (!currentUser || !currentUser.isFirebase) {
        alert('Please sign in with Google first to debug data.');
        return;
      }

      try {
        console.log('🔍 Debugging Firebase Data...');
        console.log('Current User:', currentUser);
        
        // Test Firestore connection
        const testRef = db.collection('reflections');
        const snapshot = await testRef.where('userId', '==', currentUser.id).get();
        
        console.log('Firestore Query Results:', {
          totalDocs: snapshot.size,
          docs: snapshot.docs.map(doc => ({
            id: doc.id,
            data: doc.data()
          }))
        });
        
        // Check localStorage
        const localData = localStorage.getItem('reflections');
        console.log('LocalStorage Data:', localData ? JSON.parse(localData) : 'No local data');
        
        const debugInfo = `🔍 Firebase Data Debug:

User ID: ${currentUser.id}
User Email: ${currentUser.email}

Firestore Results:
- Total documents: ${snapshot.size}
- Documents: ${snapshot.docs.map(doc => doc.data().title || 'Untitled').join(', ') || 'None'}

LocalStorage:
- Has local data: ${localData ? 'Yes' : 'No'}
- Local reflections: ${localData ? JSON.parse(localData).length : 0}

Check browser console (F12) for detailed logs.`;
        
        alert(debugInfo);
        
      } catch (error) {
        console.error('Debug error:', error);
        alert(`Debug Error: ${error.message}\n\nCheck browser console for details.`);
      }
    }

    function showFirebaseSetup() {
      const setupGuide = `🔥 Firebase Setup Guide:

✅ Step 1: Enable Authentication
1. Go to: https://console.firebase.google.com/project/spiritual-journey-e3330/authentication
2. Click "Get started"
3. Go to "Sign-in method" tab
4. Enable "Google" provider
5. Add authorized domains:
   - localhost (for testing)
   - your-domain.com (when you deploy)

✅ Step 2: Enable Firestore Database
1. Go to: https://console.firebase.google.com/project/spiritual-journey-e3330/firestore
2. Click "Create database"
3. Choose "Start in test mode"
4. Select location (closest to you)

✅ Step 3: Test Your App
1. Refresh this page
2. Click "Continue with Google"
3. Sign in with your Google account
4. Start journaling!

🎉 Your Firebase project is already configured!
Project ID: spiritual-journey-e3330
Auth Domain: spiritual-journey-e3330.firebaseapp.com

Need help? Check the console for any error messages.`;
      
      alert(setupGuide);
    }

    function setupFirebase() {
      alert('🔥 Firebase Setup:\n\n1. Go to https://console.firebase.google.com\n2. Create a new project\n3. Enable Authentication\n4. Add your domain\n5. Copy the config and paste it here\n\nFirebase is much easier than Supabase!');
    }

    function setupAuth0() {
      alert('🔐 Auth0 Setup:\n\n1. Go to https://auth0.com\n2. Create a free account\n3. Create a new application\n4. Copy the domain and client ID\n5. Add it to your app\n\nAuth0 handles all the email complexity!');
    }

    function setupClerk() {
      alert('✨ Clerk Setup:\n\n1. Go to https://clerk.com\n2. Create a free account\n3. Create a new application\n4. Copy the publishable key\n5. Add it to your app\n\nClerk has beautiful pre-built components!');
    }



    // Handle sign out
    async function handleSignOut() {
      try {
        if (currentUser && currentUser.isFirebase && auth) {
          // Firebase sign out - this will clear the session and allow account switching
          await auth.signOut();
        }
        
        // Preserve local journals; only sign out the user
        backupReflections();
        currentUser = null;
        
        // Hide sign out button and show auth screen
        document.getElementById('sign-out-btn').style.display = 'none';
        document.getElementById('main-screen').classList.add('hidden');
        document.getElementById('auth-screen').classList.remove('hidden');
        
        // Hide options menu buttons when signed out
        document.getElementById('start-journaling-btn').style.display = 'none';
        document.getElementById('past-reflections-btn').style.display = 'none';
        document.getElementById('home-btn').style.display = 'none';
        
        console.log('User signed out successfully - ready for account switching');
        
      } catch (err) {
        console.error('Sign out error:', err);
        
        // Force sign out even if there's an error
        currentUser = null;
        reflections = [];
        localStorage.removeItem('reflections');
        document.getElementById('sign-out-btn').style.display = 'none';
        document.getElementById('main-screen').classList.add('hidden');
        document.getElementById('auth-screen').classList.remove('hidden');
      }
    }

    // Migrate existing local data to user account
    async function migrateLocalData() {
      if (!currentUser) {
        console.log('No user logged in for migration');
          return;
        }

      try {
        // Check for existing local reflections
        const localReflections = localStorage.getItem('reflections');
        if (!localReflections) {
          console.log('No local data to migrate');
          return;
        }

        const localData = JSON.parse(localReflections);
        if (localData.length === 0) {
          console.log('No local reflections to migrate');
          return;
        }

        console.log('Migrating', localData.length, 'local reflections to Firebase');

        // Upload each local reflection to Firebase
        for (const reflection of localData) {
          const reflectionData = {
            title: reflection.title,
            reflection: reflection.reflection,
            date: reflection.date,
            image: reflection.image,
            created_at: reflection.created_at || new Date().toISOString()
          };

          try {
            await db.collection('reflections').add(reflectionData);
            console.log('Successfully migrated reflection:', reflection.title);
          } catch (error) {
            console.error('Error migrating reflection:', error);
          }
        }

        // Reload reflections from database
        await loadReflections();
        console.log('Data migration completed');

      } catch (err) {
        console.error('Error during data migration:', err);
      }
    }

    async function loadReflections() {
      if (!currentUser) {
        console.log('No user logged in, loading from localStorage with comprehensive backup checking');
        
        // Try to load from main storage first
        let localReflections = localStorage.getItem('reflections');
        if (localReflections) {
          try {
            reflections = JSON.parse(localReflections);
            console.log('Loaded', reflections.length, 'reflections from main localStorage');
            return;
          } catch (e) {
            console.warn('Failed to parse main reflections, trying backups:', e);
          }
        }
        
        // Try multiple backup sources in order of preference
        const backupKeys = [
          'reflections_backup_1',
          'reflections_backup_2', 
          'reflections_emergency',
          'reflections_backup'
        ];
        
        // Also check for timestamped backups
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('reflections_backup_') && key !== 'reflections_backup_1' && key !== 'reflections_backup_2') {
            backupKeys.push(key);
          }
        }
        
        for (const backupKey of backupKeys) {
          const backup = localStorage.getItem(backupKey);
          if (backup) {
            try {
              const parsed = JSON.parse(backup);
              if (parsed && Array.isArray(parsed.reflections)) {
                reflections = parsed.reflections;
                console.log(`Restored from backup ${backupKey} with`, reflections.length, 'reflections');
                
                // Try to restore images from image backups
                const restoredImages = restoreImagesFromBackups();
                if (restoredImages > 0) {
                  console.log(`Also restored ${restoredImages} images from image backups`);
                }
                
                return;
              }
            } catch (e) {
              console.warn(`Failed to parse backup ${backupKey}:`, e);
            }
          }
        }
        
        reflections = [];
        console.log('No local data available from any source');
        return;
      }
        
      // Handle Firebase mode
      if (currentUser.isFirebase) {
        console.log('Loading reflections for Firebase user:', currentUser.id);
        try {
          const snapshot = await db.collection('reflections')
            .where('userId', '==', currentUser.id)
            .orderBy('createdAt', 'desc')
            .get();
          
          trackDatabaseOperation('reads');
          
          reflections = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          
          console.log('Loaded', reflections.length, 'reflections from Firebase');
          
          // Also save to localStorage for offline access (protect newest index 0)
          saveReflectionsToLocalStorageSafely(0);
          // Create a backup
          backupReflections();
          return;
        } catch (error) {
          console.error('Error loading Firebase reflections:', error);
          console.error('Error details:', {
            code: error.code,
            message: error.message,
            userId: currentUser.id
          });
          
          // Decide how to surface this error
          const isExplicitFirestoreQuota = error && (error.code === 'resource-exhausted' || error.code === 'permission-denied:RESOURCE_EXHAUSTED');
          const browserMsg = (error && (error.message || error.name || '')).toLowerCase();
          const isBrowserStorageQuota = !isExplicitFirestoreQuota && browserMsg.includes('quota');

          if (isExplicitFirestoreQuota) {
            // Store quota error timestamp only for explicit Firestore quota errors
            localStorage.setItem('lastQuotaError', Date.now().toString());
            alert(`📊 Firebase Quota Exceeded\n\nYour Firebase quota has been reached.\n\n✅ Your journals are saved locally and will sync when quota resets.`);
          } else if (error.code === 'permission-denied') {
            alert(`🔒 Permission Denied\n\nThere's an issue with database permissions.\n\n✅ Your journals are saved locally and will sync when fixed.`);
          } else if (error.code === 'unavailable') {
            alert(`🌐 Service Unavailable\n\nFirebase is temporarily unavailable.\n\n✅ Your journals are saved locally and will sync when service returns.`);
          } else if (!isBrowserStorageQuota) {
            // Only show a generic connection alert if this is NOT a local browser storage quota
            alert(`⚠️ Connection Error\n\nError: ${error.message}\n\n✅ Your journals are saved locally and will sync when connection is restored.`);
          } else {
            console.warn('Local browser storage quota issue while loading. Falling back to existing local data.');
          }
          
          // Fallback to local backups/localStorage
          let localReflections = localStorage.getItem('reflections');
          if (!localReflections) {
            const backup = localStorage.getItem('reflections_backup');
            if (backup) {
              try {
                const parsed = JSON.parse(backup);
                if (parsed && Array.isArray(parsed.reflections)) {
                  reflections = parsed.reflections;
                  console.log('Restored from backup with', reflections.length, 'reflections');
                  saveReflectionsToLocalStorageSafely();
                  return;
                }
              } catch (e) {
                console.warn('Failed to parse backup:', e);
              }
            }
          }
          if (localReflections) {
            reflections = JSON.parse(localReflections);
            console.log('Using localStorage fallback with', reflections.length, 'reflections');
          } else {
            reflections = [];
            console.log('No local data available');
          }
          return;
        }
      }
        
      // Fallback for non-Firebase users (should not happen in current setup)
      console.log('No Firebase user detected, showing empty reflections');
      reflections = [];
    }

    async function saveReflections() {
      // Get form data
      const title = document.getElementById('title').value.trim();
      const reflection = document.getElementById('reflection').value.trim();
      const date = document.getElementById('entry-date').textContent;
      
      if (!currentUser) {
        console.log('No user logged in, saving to localStorage only');
        // Save to localStorage when no user is signed in
        const localData = {
          title,
          reflection,
          date,
          image: currentImage || '',
          createdAt: new Date().toISOString()
        };
        
        if (editingIndex !== null && reflections[editingIndex]) {
          reflections[editingIndex] = localData;
        } else {
          reflections.unshift(localData);
        }
        
        saveReflectionsToLocalStorageSafely();
        currentImage = "";
        editingIndex = null;
        goBack();
        return;
      }
      
      // Debug logging
      console.log('💾 Saving reflection with data:', {
        title: title,
        reflection: reflection,
        hasImage: !!currentImage,
        imageLength: currentImage ? currentImage.length : 0,
        date: date
      });
      
      // Handle Firebase mode
      if (currentUser.isFirebase) {
        console.log('Saving reflection for Firebase user');
        
        const reflectionData = {
          userId: currentUser.id,
          title,
          reflection,
          date,
          image: currentImage || '', // Ensure image is always a string
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        try {
          // Disable save button during save process
          const saveButton = document.getElementById('save');
          saveButton.disabled = true;
          saveButton.textContent = 'Saving...';
          
          if (editingIndex !== null && reflections[editingIndex]) {
            // Update existing reflection
            console.log('📝 Updating existing reflection');
            await db.collection('reflections').doc(reflections[editingIndex].id).update(reflectionData);
            trackDatabaseOperation('writes');
            reflections[editingIndex] = { ...reflections[editingIndex], ...reflectionData };
            console.log('✅ Reflection updated successfully');
          } else {
            // Add new reflection
            console.log('📝 Adding new reflection');
            const docRef = await db.collection('reflections').add(reflectionData);
            trackDatabaseOperation('writes');
            reflections.unshift({ id: docRef.id, ...reflectionData });
            console.log('✅ Reflection added successfully with ID:', docRef.id);
          }
          
          // Also save to localStorage for offline access
          saveReflectionsToLocalStorageSafely();
          
          // Clear form and go back
          currentImage = "";
          editingIndex = null;
          
          // Reset save button
          saveButton.disabled = false;
          saveButton.textContent = 'Save Reflection';
          
          goBack();
          return;
        } catch (error) {
          console.error('Error saving to Firebase:', error);
          console.error('Error details:', {
            code: error.code,
            message: error.message,
            userId: currentUser.id,
            reflectionData: reflectionData
          });
          
          // Reset save button
          const saveButton = document.getElementById('save');
          saveButton.disabled = false;
          saveButton.textContent = 'Save Reflection';
          
          // Handle specific error types (only show quota when Firestore explicitly reports it)
          let errorMessage = '';
          if (error && (error.code === 'resource-exhausted' || error.code === 'permission-denied:RESOURCE_EXHAUSTED')) {
            errorMessage = `📊 Firebase Quota Exceeded\n\nYour Firebase quota has been reached.\n\n✅ Your journal has been saved locally and will sync when quota resets.`;
          } else if (error.code === 'permission-denied') {
            errorMessage = `🔒 Permission Denied\n\nThere's an issue with database permissions.\n\n✅ Your journal has been saved locally and will sync when fixed.`;
          } else if (error.code === 'unavailable') {
            errorMessage = `🌐 Service Unavailable\n\nFirebase is temporarily unavailable.\n\n✅ Your journal has been saved locally and will sync when service returns.`;
          } else {
            errorMessage = `⚠️ Save Error\n\nError: ${error.message}\n\n✅ Your journal has been saved locally and will sync when connection is restored.`;
          }
          
          // Show user-friendly error message
          alert(errorMessage);
          
          // Fallback to localStorage
          const localData = {
            id: 'firebase_fallback_' + Date.now(),
            ...reflectionData,
            createdAt: new Date().toISOString()
          };
          
          if (editingIndex !== null && reflections[editingIndex]) {
            reflections[editingIndex] = localData;
          } else {
            reflections.unshift(localData);
          }
          
          localStorage.setItem('reflections', JSON.stringify(reflections));
          currentImage = "";
          editingIndex = null;
          goBack();
          return;
        }
      }
      
      // Fallback for non-Firebase users (should not happen in current setup)
      console.log('No Firebase user detected, cannot save reflection');
      alert('Please sign in with Google to save your reflections.');
    }


    function showEntryScreen(index = null) {
      // No authentication required - allow everyone to create reflections
      document.getElementById('main-screen').classList.add('hidden');
      document.getElementById('entry-screen').classList.remove('hidden');
      document.getElementById('history-screen').classList.add('hidden');
      document.getElementById('options-menu').style.display = 'none';
      
      // Hide the back button when going to entry screen
      document.getElementById('back-to-inspire-btn').style.display = 'none';
      document.getElementById('title').value = '';
      document.getElementById('reflection').value = '';
      document.getElementById('image-input').value = '';
      document.getElementById('image-preview-container').style.display = 'none';
      currentImage = "";
      editingIndex = index;
      if (index !== null && reflections[index]) {
        document.getElementById('title').value = reflections[index].title;
        document.getElementById('reflection').value = reflections[index].reflection;
        if (reflections[index].image) {
          const preview = document.getElementById('preview-image');
          const container = document.getElementById('image-preview-container');
          const loading = document.getElementById('image-loading');
          
          preview.src = reflections[index].image;
          container.style.display = 'block';
          loading.style.display = 'none';
          preview.style.display = 'block';
          currentImage = reflections[index].image;
        }
      }
      // Ensure save button is properly enabled/disabled
      checkSaveEnabled();
      document.getElementById('start-voice').disabled = false;
      newQuestion();
      updateDateTime();
    }

    function goBack(showWelcome = false) {
      if (recognition) recognition.stop();
      document.getElementById('entry-screen').classList.add('hidden');
      document.getElementById('history-screen').classList.add('hidden');
      document.getElementById('options-menu').style.display = 'none';
      document.getElementById('main-screen').classList.remove('hidden');
      editingIndex = null;
      
      // Hide the back button when returning to main screen
      document.getElementById('back-to-inspire-btn').style.display = 'none';
      
      // Show welcome message if user just signed up
      if (showWelcome && user) {
        const welcomeMessage = document.getElementById('welcome-message');
        welcomeMessage.textContent = 'Welcome! Your account has been created and you\'re now logged in.';
        welcomeMessage.style.display = 'block';
        
        // Hide welcome message after 5 seconds
        setTimeout(() => {
          welcomeMessage.style.display = 'none';
        }, 5000);
      }
    }
    
    function goBackToInspire() {
      // This function is called from the back button on main screen
      // It's essentially the same as goBack() but more explicit
      goBack();
    }
    
    function goToHome() {
      // Navigate to home page from anywhere in the app
      document.getElementById('entry-screen').classList.add('hidden');
      document.getElementById('history-screen').classList.add('hidden');
      document.getElementById('options-menu').style.display = 'none';
      document.getElementById('main-screen').classList.remove('hidden');
      
      // Hide the back button when going to home
      document.getElementById('back-to-inspire-btn').style.display = 'none';
      
      // Reset any editing state
      editingIndex = null;
    }

    async function showHistory() {
      // No authentication required - allow everyone to view reflections
      document.getElementById('main-screen').classList.add('hidden');
      document.getElementById('entry-screen').classList.add('hidden');
      document.getElementById('history-screen').classList.remove('hidden');
      document.getElementById('options-menu').style.display = 'none';
      
      // Show the back button on main screen when viewing history
      document.getElementById('back-to-inspire-btn').style.display = 'block';
      
      await loadReflections();
      refreshHistoryDisplay();
    }

    function editReflection(index) {
      showEntryScreen(index);
    }

    function reviewReflection(index) {
      alert(`Title: ${reflections[index].title}\n\nReflection: ${reflections[index].reflection}\n\nDate: ${reflections[index].date}`);
    }

    function debugReflections() {
      console.log('=== DEBUG REFLECTIONS ===');
      console.log('Reflections array:', reflections);
      console.log('Reflections length:', reflections.length);
      console.log('localStorage reflections:', localStorage.getItem('reflections'));
      
      // Show detailed info about each reflection
      let debugInfo = `Total reflections: ${reflections.length}\n\n`;
      reflections.forEach((reflection, index) => {
        const date = reflection.createdAt ? 
          (reflection.createdAt.toDate ? reflection.createdAt.toDate() : new Date(reflection.createdAt)) :
          (reflection.date ? new Date(reflection.date) : 'No date');
        debugInfo += `${index + 1}. "${reflection.title || 'Untitled'}" - ${date}\n`;
      });
      
      debugInfo += `\nCheck console for full details.`;
      alert(debugInfo);
    }

    function checkLocalStorage() {
      console.log('=== LOCAL STORAGE CHECK ===');
      
      const reflections = localStorage.getItem('reflections');
      const backup = localStorage.getItem('reflections_backup');
      
      console.log('Main reflections:', reflections);
      console.log('Backup reflections:', backup);
      
      let storageInfo = 'LocalStorage Contents:\n\n';
      
      if (reflections) {
        try {
          const parsed = JSON.parse(reflections);
          storageInfo += `Main storage: ${Array.isArray(parsed) ? parsed.length : 'Not an array'} items\n`;
          if (Array.isArray(parsed)) {
            parsed.forEach((item, index) => {
              const date = item.createdAt || item.date || 'No date';
              storageInfo += `  ${index + 1}. "${item.title || 'Untitled'}" - ${date}\n`;
            });
          }
        } catch (e) {
          storageInfo += `Main storage: Error parsing - ${e.message}\n`;
        }
            } else {
        storageInfo += 'Main storage: Empty\n';
      }
      
      if (backup) {
        try {
          const parsed = JSON.parse(backup);
          storageInfo += `\nBackup storage: ${parsed.reflections ? parsed.reflections.length : 'No reflections array'} items\n`;
          if (parsed.reflections && Array.isArray(parsed.reflections)) {
            parsed.reflections.forEach((item, index) => {
              const date = item.createdAt || item.date || 'No date';
              storageInfo += `  ${index + 1}. "${item.title || 'Untitled'}" - ${date}\n`;
            });
          }
        } catch (e) {
          storageInfo += `\nBackup storage: Error parsing - ${e.message}\n`;
        }
            } else {
        storageInfo += '\nBackup storage: Empty\n';
      }
      
      alert(storageInfo);
    }

    function clearOldImages() {
      if (!reflections || reflections.length === 0) {
        alert('No journals to process.');
        return;
      }
      
      let imagesCleared = 0;
      let spaceSaved = 0;
      
      // Clear images from all but the 3 most recent journals
      for (let i = 3; i < reflections.length; i++) {
        if (reflections[i] && reflections[i].image && reflections[i].image.length > 0) {
          spaceSaved += reflections[i].image.length;
          reflections[i] = { ...reflections[i], image: '' };
          imagesCleared++;
        }
      }
      
      if (imagesCleared > 0) {
        try {
          saveReflectionsToLocalStorageSafely();
          const spaceSavedKB = Math.round(spaceSaved / 1024);
          alert(`✅ Cleared ${imagesCleared} old images\n\nSaved approximately ${spaceSavedKB} KB of storage space.\n\nYour journals are preserved, only images were removed.`);
        } catch (e) {
          alert(`❌ Error saving changes: ${e.message}`);
        }
            } else {
        alert('No old images found to clear.\n\nOnly the 3 most recent journals keep their images.');
      }
    }

    function exportJournals() {
      if (!reflections || reflections.length === 0) {
        alert('No journals to export.');
        return;
      }
      
      // Create export data
      const exportData = {
        exportDate: new Date().toISOString(),
        totalJournals: reflections.length,
        journals: reflections.map((journal, index) => ({
          number: index + 1,
          title: journal.title || 'Untitled',
          content: journal.reflection || '',
          date: journal.date || journal.createdAt || 'No date',
          hasImage: !!(journal.image && journal.image.length > 0),
          image: journal.image || null // Include the actual image data
        }))
      };
      
      // Create downloadable file
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      
      // Create download link
      const link = document.createElement('a');
      link.href = url;
      link.download = `my-journals-export-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      alert(`✅ Exported ${reflections.length} journals\n\nFile saved as: ${link.download}\n\nYou can now safely clear old journals to free up space.`);
    }

    function aggressiveCleanup() {
      if (!reflections || reflections.length === 0) {
        alert('No journals to process.');
          return;
        }
        
      const originalCount = reflections.length;
      let spaceSaved = 0;
      let imagesCleared = 0;
      
      // Clear ALL images from journals older than the 2 most recent
      for (let i = 2; i < reflections.length; i++) {
        if (reflections[i] && reflections[i].image && reflections[i].image.length > 0) {
          spaceSaved += reflections[i].image.length;
          reflections[i] = { ...reflections[i], image: '' };
          imagesCleared++;
        }
      }
      
      // Also clear any other localStorage data that might be taking space
      try {
        // Clear backup if it exists (we'll recreate it)
        localStorage.removeItem('reflections_backup');
        
        // Clear any other app data
        const keysToCheck = ['lastQuotaError', 'dailyUsage', 'failedDeletions'];
        keysToCheck.forEach(key => {
          if (localStorage.getItem(key)) {
            localStorage.removeItem(key);
          }
        });
        
        // Save the cleaned reflections
        saveReflectionsToLocalStorageSafely();
        
        const spaceSavedKB = Math.round(spaceSaved / 1024);
        alert(`✅ Aggressive cleanup completed!\n\n• Cleared ${imagesCleared} images\n• Removed backup data\n• Cleared app cache\n• Saved ~${spaceSavedKB} KB\n\nYour ${originalCount} journals are preserved with only the 2 most recent keeping their images.`);
        
      } catch (e) {
        alert(`❌ Error during cleanup: ${e.message}\n\nTry exporting your journals first as a backup.`);
      }
    }

    function restoreFromBackup() {
      const backupKeys = [];
      
      // Find all available backups
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('reflections_backup_') || key === 'reflections_backup')) {
          backupKeys.push(key);
        }
      }
      
      if (backupKeys.length === 0) {
        alert('No backups found in localStorage.');
        return;
      }
      
      // Show available backups
      let backupInfo = 'Available Backups:\n\n';
      backupKeys.forEach((key, index) => {
        try {
          const backup = localStorage.getItem(key);
          const parsed = JSON.parse(backup);
          const count = parsed.reflections ? parsed.reflections.length : 0;
          const date = parsed.timestamp ? new Date(parsed.timestamp).toLocaleString() : 'Unknown date';
          backupInfo += `${index + 1}. ${key} (${count} journals, ${date})\n`;
        } catch (e) {
          backupInfo += `${index + 1}. ${key} (corrupted)\n`;
        }
      });
      
      const choice = prompt(backupInfo + '\nEnter the number of the backup to restore (or 0 to cancel):');
      const choiceNum = parseInt(choice);
      
      if (choiceNum === 0 || isNaN(choiceNum) || choiceNum < 1 || choiceNum > backupKeys.length) {
        return;
      }
      
      const selectedKey = backupKeys[choiceNum - 1];
      try {
        const backup = localStorage.getItem(selectedKey);
        const parsed = JSON.parse(backup);
        
        if (parsed && Array.isArray(parsed.reflections)) {
          reflections = parsed.reflections;
          saveReflectionsToLocalStorageSafely();
          alert(`✅ Restored ${reflections.length} journals from backup: ${selectedKey}\n\nYour journals have been restored successfully!`);
          refreshHistoryDisplay();
        } else {
          alert('❌ Selected backup is corrupted or empty.');
        }
      } catch (e) {
        alert(`❌ Error restoring backup: ${e.message}`);
      }
    }

    // Proactive storage monitoring
    function checkStorageHealth() {
      try {
        // Test if we can still write to localStorage
        const testData = 'storage_test_' + Date.now();
        localStorage.setItem(testData, 'test');
        localStorage.removeItem(testData);
        
        // Estimate current storage usage
        let totalSize = 0;
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key) {
            totalSize += localStorage.getItem(key).length;
          }
        }
        
        const sizeKB = Math.round(totalSize / 1024);
        console.log(`Storage health check: ${sizeKB} KB used`);
        
        // If we're using more than 4MB, warn the user
        if (sizeKB > 4000) {
          console.warn('Storage usage is high:', sizeKB, 'KB');
          if (sizeKB > 5000) {
            alert(`⚠️ Storage Warning\n\nYour browser storage is getting full (${sizeKB} KB used).\n\nTo prevent data loss:\n• Export your journals\n• Clear old images\n• Sign in to sync to cloud storage`);
          }
        }
        
        return sizeKB;
      } catch (e) {
        console.error('Storage health check failed:', e);
        alert(`🚨 Storage Error\n\nUnable to write to browser storage. This may cause data loss.\n\nPlease:\n1. Export your journals immediately\n2. Clear browser cache\n3. Sign in to sync to cloud storage`);
        return -1;
      }
    }

    function smartImageManagement() {
      if (!reflections || reflections.length === 0) {
        alert('No journals to process.');
        return;
      }
      
      let totalImages = 0;
      let largeImages = 0;
      let totalImageSize = 0;
      let compressedCount = 0;
      
      // Analyze current images
      reflections.forEach((reflection, index) => {
        if (reflection.image && reflection.image.length > 0) {
          totalImages++;
          totalImageSize += reflection.image.length;
          if (reflection.image.length > 100000) { // >100KB
            largeImages++;
          }
        }
      });
      
      const totalSizeMB = Math.round(totalImageSize / (1024 * 1024) * 100) / 100;
      
      if (totalImages === 0) {
        alert('No images found in your journals.');
        return;
      }
      
      const action = confirm(`📸 Image Analysis:\n\n• Total images: ${totalImages}\n• Large images (>100KB): ${largeImages}\n• Total image size: ${totalSizeMB} MB\n\nWould you like to:\n• Compress large images (keeps all images, reduces size)\n• Cancel (keep everything as is)`);
      
      if (action) {
        // Compress large images
        reflections.forEach((reflection, index) => {
          if (reflection.image && reflection.image.length > 100000) {
            try {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();
              
              img.onload = function() {
                // Reduce size by 60% and quality to 80%
                canvas.width = img.width * 0.6;
                canvas.height = img.height * 0.6;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                const compressedImage = canvas.toDataURL('image/jpeg', 0.8);
                const originalSize = reflection.image.length;
                const newSize = compressedImage.length;
                const saved = Math.round((originalSize - newSize) / 1024);
                
                reflection.image = compressedImage;
                compressedCount++;
                
                console.log(`Compressed image for "${reflection.title}": saved ${saved} KB`);
              };
              
              img.src = reflection.image;
            } catch (e) {
              console.warn(`Failed to compress image for reflection ${index}:`, e);
            }
          }
        });
        
        // Save the compressed reflections
        try {
          saveReflectionsToLocalStorageSafely();
          alert(`✅ Smart Image Management Complete!\n\n• Compressed ${compressedCount} large images\n• All images preserved\n• Reduced storage usage\n• Images are now optimized for better performance`);
        } catch (e) {
          alert(`❌ Error saving compressed images: ${e.message}`);
        }
      }
    }

    function clearBrowserCache() {
      try {
        // Clear localStorage
        localStorage.clear();
        // Clear sessionStorage
        sessionStorage.clear();
        console.log('Browser cache cleared');
        return true;
      } catch (err) {
        console.error('Error clearing cache:', err);
        return false;
      }
    }


    function refreshHistoryDisplay() {
      console.log('Refreshing history display with', reflections.length, 'reflections');
      console.log('Reflections array:', reflections);
      const list = document.getElementById('history-list');
      
      if (!list) {
        console.error('History list element not found!');
        return;
      }
      
      list.innerHTML = '';

      // Try to reduce memory pressure by stripping images if cache is too large
      try {
        // Attempt to serialize; if it fails due to size, trim images
        JSON.stringify(reflections);
      } catch (_) {
        for (let i = reflections.length - 1; i >= 0; i--) {
          if (reflections[i] && reflections[i].image) {
            reflections[i] = { ...reflections[i], image: '' };
          }
        }
        saveReflectionsToLocalStorageSafely();
      }
      
      if (!reflections || reflections.length === 0) {
        list.innerHTML = '<p>No reflections yet. Start journaling to see them here!</p>';
        console.log('No reflections to display');
        return;
      }
      
      reflections.forEach((item, index) => {
        console.log('Creating display for reflection', index, ':', item.title);
        
        // Format the date and time properly
        let displayDate = 'No date';
        if (item.createdAt) {
          // Handle Firebase timestamp
          const date = item.createdAt.toDate ? item.createdAt.toDate() : new Date(item.createdAt);
          displayDate = date.toLocaleString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
          });
        } else if (item.date) {
          // Fallback to the date field
          displayDate = item.date;
        }
        
        const div = document.createElement('div');
        div.className = 'history-item';
        div.innerHTML = `
          <h3>${item.title || 'Untitled'}</h3>
          <p>${item.reflection || 'No content'}</p>
          <small style="color: var(--text-muted); font-size: 0.85rem; margin-top: 8px; display: block;">${displayDate}</small>
          ${item.image ? `<img src="${item.image}">` : ""}
          <div class="button-group">
            <button class="button" onclick="editReflection(${index})">Edit</button>
            <button class="button" onclick="reviewReflection(${index})">Review</button>
            <button class="button" onclick="deleteReflection(${index})" onmouseover="console.log('Delete button hovered, index:', ${index})">Delete</button>
          </div>
        `;
        list.appendChild(div);
      });
      
      console.log('History display refreshed with', reflections.length, 'items');
    }

    async function deleteReflection(index) {
      console.log('=== DELETE FUNCTION CALLED ===');
      console.log('Delete function called with index:', index);
      console.log('Index type:', typeof index);
      console.log('Current reflections array length:', reflections ? reflections.length : 'undefined');
      console.log('Current reflections array:', reflections);
      
      // Convert index to number if it's a string
      if (typeof index === 'string') {
        index = parseInt(index, 10);
        console.log('Converted index to number:', index);
      }
      
      // Ensure reflections array is initialized
      if (!reflections) {
        console.error('Reflections array is not initialized');
        try {
          await loadReflections();
          console.log('Reloaded reflections, new length:', reflections.length);
        } catch (loadErr) {
          console.error('Failed to reload reflections:', loadErr);
          alert('Failed to load reflections. Please refresh the page and try again.');
          return;
        }
      }
      
      if (!reflections || reflections.length === 0) {
        console.error('No reflections found');
        alert('No reflections found. Please refresh the page and try again.');
        return;
      }
      
      if (index < 0 || index >= reflections.length) {
        console.error('Invalid index:', index, 'for array length:', reflections.length);
        alert('Invalid reflection index. Please refresh the page and try again.');
        return;
      }
      
      if (!reflections[index]) {
        console.error('Reflection not found at index:', index);
        alert('Reflection not found. Please refresh the page and try again.');
        return;
      }
      
      console.log('About to show confirmation dialog');
      if (confirm('Are you sure you want to delete this reflection?')) {
        console.log('User confirmed deletion');
        try {
          // Always perform local deletion first
          const deletedReflection = reflections.splice(index, 1)[0];
          console.log('Deleted reflection:', deletedReflection);
          console.log('Remaining reflections:', reflections.length);
          
          // Update localStorage immediately
          try {
            saveReflectionsToLocalStorageSafely();
            console.log('Updated reflections in localStorage');
          } catch (localErr) {
            console.error('Error updating localStorage:', localErr);
            throw new Error('Failed to save changes locally: ' + localErr.message);
          }
          
          // Try database deletion if the reflection has an ID and user is logged in
          if (deletedReflection.id && currentUser && currentUser.isFirebase) {
            try {
              console.log('Attempting Firebase deletion for ID:', deletedReflection.id);
              await db.collection('reflections').doc(deletedReflection.id).delete();
              trackDatabaseOperation('deletes');
              console.log('Firebase deletion successful');
            } catch (dbErr) {
              console.error('Firebase deletion failed:', dbErr);
              // Store the failed deletion for retry
              const failedDeletions = JSON.parse(localStorage.getItem('failedDeletions') || '[]');
              failedDeletions.push({
                id: deletedReflection.id,
                timestamp: Date.now(),
                retryCount: 0
              });
              localStorage.setItem('failedDeletions', JSON.stringify(failedDeletions));
              
              // Show retry option
              if (confirm('Reflection deleted locally but database sync failed. Would you like to retry the sync now?')) {
                await retryFailedDeletions();
              } else {
                alert('Reflection deleted locally. You can retry the sync later or it will be removed when you refresh.');
              }
            }
          } else {
            console.log('No database ID found or user not logged in, local deletion only');
          }
          
          // Refresh the history display without reloading from storage
          try {
            console.log('Calling refreshHistoryDisplay with', reflections.length, 'reflections');
            refreshHistoryDisplay();
            alert('Reflection deleted successfully!');
          } catch (displayErr) {
            console.error('Error refreshing display:', displayErr);
            throw new Error('Failed to refresh display: ' + displayErr.message);
          }
          
        } catch (err) {
          console.error('Unexpected error deleting reflection:', err);
          console.error('Error details:', err.message, err.stack);
          alert(`Error deleting reflection: ${err.message}. Please check the console for details.`);
        }
      }
    }

    // Retry failed deletions
    async function retryFailedDeletions() {
      try {
        const failedDeletions = JSON.parse(localStorage.getItem('failedDeletions') || '[]');
        if (failedDeletions.length === 0) {
          console.log('No failed deletions to retry');
          return;
        }

        console.log('Retrying', failedDeletions.length, 'failed deletions');
        let successCount = 0;
        let remainingFailures = [];

        for (const failedDeletion of failedDeletions) {
          try {
            await db.collection('reflections').doc(failedDeletion.id).delete();
            trackDatabaseOperation('deletes');
            console.log('Successfully deleted ID:', failedDeletion.id);
            successCount++;
          } catch (err) {
            console.error('Retry error for ID:', failedDeletion.id, err);
            failedDeletion.retryCount = (failedDeletion.retryCount || 0) + 1;
            if (failedDeletion.retryCount < 3) {
              remainingFailures.push(failedDeletion);
            }
          }
        }

        // Update the failed deletions list
        localStorage.setItem('failedDeletions', JSON.stringify(remainingFailures));

        if (successCount > 0) {
          alert(`Successfully synced ${successCount} deletion(s) to the database!`);
        }
        
        if (remainingFailures.length > 0) {
          console.log('Still have', remainingFailures.length, 'failed deletions');
        } else {
          console.log('All failed deletions have been resolved');
        }

      } catch (err) {
        console.error('Error retrying failed deletions:', err);
        alert('Error retrying failed deletions. Please try again later.');
      }
    }

    // Auto-retry failed deletions on page load (only if quota allows)
    async function autoRetryFailedDeletions() {
      try {
        const failedDeletions = JSON.parse(localStorage.getItem('failedDeletions') || '[]');
        if (failedDeletions.length > 0) {
          console.log('Found', failedDeletions.length, 'failed deletions, attempting auto-retry');
          // Only retry if we haven't hit quota recently
          const lastQuotaError = localStorage.getItem('lastQuotaError');
          const now = Date.now();
          if (!lastQuotaError || (now - parseInt(lastQuotaError)) > 3600000) { // 1 hour
            await retryFailedDeletions();
          } else {
            console.log('Skipping auto-retry due to recent quota error');
          }
        }
      } catch (err) {
        console.error('Error in auto-retry:', err);
      }
    }

    // Track database operations for quota management
    function trackDatabaseOperation(operation) {
      const today = new Date().toDateString();
      const key = `${operation}_${today}`;
      const current = parseInt(localStorage.getItem(key) || '0');
      localStorage.setItem(key, (current + 1).toString());
      console.log(`📊 Database ${operation}: ${current + 1} today`);
    }

    // Check and display quota status
    function checkQuotaStatus() {
      const lastQuotaError = localStorage.getItem('lastQuotaError');
      const quotaStatus = document.getElementById('quota-status');
      
      if (lastQuotaError) {
        const now = Date.now();
        const timeSinceError = now - parseInt(lastQuotaError);
        const hoursSinceError = Math.floor(timeSinceError / 3600000);
        
        if (hoursSinceError < 24) {
          quotaStatus.textContent = `📊 Firebase quota exceeded ${hoursSinceError}h ago. Your data is saved locally and will sync when quota resets.`;
          quotaStatus.style.display = 'block';
        } else {
          // Quota should have reset, hide the message
          quotaStatus.style.display = 'none';
          localStorage.removeItem('lastQuotaError');
        }
      } else {
        quotaStatus.style.display = 'none';
      }
    }
    
    // Function to test Firebase connection and detect upgrade status
    async function testFirebaseConnection() {
      try {
        if (!db) {
          console.log('Firebase not initialized');
          return false;
        }
        
        // Try a simple read operation to test connection
        const testDoc = await db.collection('test').doc('connection').get();
        console.log('Firebase connection test successful');
        return true;
      } catch (error) {
        console.log('Firebase connection test failed:', error);
        if (error.code === 'resource-exhausted') {
          console.log('Quota still exceeded - upgrade may not be active yet');
        }
        return false;
      }
    }
    
    
    // Reset user quota state function
    function resetUserQuotaState() {
      // Clear all quota-related localStorage
      localStorage.removeItem('lastQuotaError');
      localStorage.removeItem('failedDeletions');
      
      // Clear daily usage counters
      const today = new Date().toDateString();
      localStorage.removeItem(`reads_${today}`);
      localStorage.removeItem(`writes_${today}`);
      localStorage.removeItem(`deletes_${today}`);
      
      alert('✅ User quota state reset!\n\nAll quota error tracking has been cleared. Try using the app again.');
    }

    // Theme switching functions
    function toggleTheme() {
      const themeToggle = document.getElementById('theme-toggle');
      const sun = document.querySelector('.sun');
      
      if (currentTheme === 'dark') {
        // Switch to sky theme
        document.documentElement.setAttribute('data-theme', 'sky');
        currentTheme = 'sky';
        themeToggle.textContent = '🌙';
        sun.style.display = 'block';
        localStorage.setItem('theme', 'sky');
      } else {
        // Switch to dark theme
        document.documentElement.removeAttribute('data-theme');
        currentTheme = 'dark';
        themeToggle.textContent = '☀️';
        sun.style.display = 'none';
        localStorage.setItem('theme', 'dark');
      }
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeToggle = document.getElementById('theme-toggle');
      const sun = document.querySelector('.sun');
      
      if (savedTheme === 'sky') {
        document.documentElement.setAttribute('data-theme', 'sky');
        currentTheme = 'sky';
        themeToggle.textContent = '🌙';
        sun.style.display = 'block';
      } else {
        document.documentElement.removeAttribute('data-theme');
        currentTheme = 'dark';
        themeToggle.textContent = '☀️';
        sun.style.display = 'none';
      }
    }

    function startVoiceRecognition() {
      if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
        alert('Speech recognition is not supported in your browser. Use Chrome.');
        return;
      }
      recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = 'en-US';
      recognition.interimResults = true;
      recognition.continuous = true;
      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const chunk = res[0].transcript;
          if (res.isFinal) {
            appendSmartSentence(chunk);
          }
        }
        checkSaveEnabled();
      };
      recognition.onend = () => {
        // Voice recognition ended, user can now save
        console.log('Voice recognition ended');
      };
      recognition.onerror = () => {
        console.log('Voice recognition error');
      };
      recognition.start();
    }

    function stopVoiceRecognition() {
      if (recognition) recognition.stop();
    }

    function appendSmartSentence(text) {
      const box = document.getElementById('reflection');
      let t = (text || '').trim();
      if (!t) return;
      t = t.replace(/\s+/g, ' ');
      t = t.charAt(0).toUpperCase() + t.slice(1);
      if (!/[.!?…]$/.test(t)) {
        t += '.';
      }
      t += ' ';
      const existing = box.value;
      const needsSpace = existing && !/\s$/.test(existing);
      box.value = existing + (needsSpace ? ' ' : '') + t;
      box.selectionStart = box.selectionEnd = box.value.length;
    }

    function checkSaveEnabled() {
      document.getElementById('save').disabled = !canSave();
    }

    function canSave() {
      const title = document.getElementById('title').value.trim();
      const reflection = document.getElementById('reflection').value.trim();
      const hasImage = currentImage && currentImage.trim() !== '';
      
      const canSaveResult = !!(title && (reflection || hasImage));
      
      // Debug logging
      console.log('🔍 canSave check:', {
        title: title,
        reflection: reflection,
        hasImage: hasImage,
        currentImageLength: currentImage ? currentImage.length : 0,
        canSave: canSaveResult
      });
      
      // Can save if there's a title and either reflection text OR an image
      return canSaveResult;
    }

    async function saveReflection() {
      await saveReflections();
    }

    function previewImage(event) {
      console.log('📷 Photo upload triggered');
      console.log('Event:', event);
      console.log('Files:', event.target.files);
      
      const file = event.target.files[0];
      if (file) {
        console.log('✅ File selected successfully');
        console.log('Selected file:', file.name, 'Type:', file.type, 'Size:', file.size, 'bytes');
        
        // Accept any file type and size - compression will handle large files
        console.log('📁 File accepted:', {
          name: file.name,
          type: file.type,
          size: (file.size / 1024 / 1024).toFixed(2) + ' MB'
        });
        
        const reader = new FileReader();
        const container = document.getElementById('image-preview-container');
        const loading = document.getElementById('image-loading');
        const preview = document.getElementById('preview-image');
        
        // Show loading indicator
        container.style.display = 'block';
        loading.style.display = 'block';
        preview.style.display = 'none';
        
        reader.onload = (e) => {
          try {
            // Compress the image before storing
            compressImage(e.target.result, (compressedDataUrl) => {
              // Set the compressed image source
              preview.src = compressedDataUrl;
              currentImage = compressedDataUrl;
            
            // Hide loading and show image
            loading.style.display = 'none';
            preview.style.display = 'block';
              
              // Check if save button should be enabled
              checkSaveEnabled();
            
            // Add a small delay to ensure the image loads
            setTimeout(() => {
              if (preview.complete && preview.naturalHeight !== 0) {
                console.log('✅ Image preview loaded successfully:', file.name);
                console.log('📏 Image dimensions:', preview.naturalWidth, 'x', preview.naturalHeight);
                  console.log('💾 Original size:', (file.size / 1024 / 1024).toFixed(2), 'MB');
                  console.log('💾 Compressed size:', (compressedDataUrl.length / 1024 / 1024).toFixed(2), 'MB');
              } else {
                console.log('⏳ Image preview loading...');
              }
            }, 100);
            });
          } catch (error) {
            console.error('Error processing image:', error);
            alert('Error processing the file. Please try a different file.\n\nThe app supports any image format and will automatically compress large files.');
            container.style.display = 'none';
          }
        };
        
        reader.onerror = () => {
          alert('Error reading the file. Please try again.\n\nThis might happen if:\n• The file is corrupted\n• The file format is not supported\n• There\'s insufficient memory\n• The file is too large for your device\n\nTry selecting a different file or a smaller image.');
          console.error('FileReader error:', reader.error);
          container.style.display = 'none';
        };
        
        // Read the file
        reader.readAsDataURL(file);
      } else {
        console.log('❌ No file selected');
        alert('No file selected. Please try again.');
      }
    }

    function compressImage(dataUrl, callback) {
      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Calculate new dimensions (max 1200px width/height for better quality)
        let { width, height } = img;
        const maxSize = 1200;
        
        if (width > height) {
          if (width > maxSize) {
            height = (height * maxSize) / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width = (width * maxSize) / height;
            height = maxSize;
          }
        }
        
        // Set canvas dimensions
        canvas.width = width;
        canvas.height = height;
        
        // Draw and compress
        ctx.drawImage(img, 0, 0, width, height);
        
        // Try different quality levels to get under 1MB
        let quality = 0.9;
        let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
        
        // If still too large, reduce quality further
        while (compressedDataUrl.length > 1000000 && quality > 0.1) { // 1MB limit
          quality -= 0.1;
          compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
        }
        
        // If still too large, reduce dimensions progressively
        if (compressedDataUrl.length > 1000000) {
          let scaleFactor = 0.8;
          while (compressedDataUrl.length > 1000000 && scaleFactor > 0.3) {
            canvas.width = width * scaleFactor;
            canvas.height = height * scaleFactor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
            scaleFactor -= 0.1;
          }
        }
        
        console.log('🔄 Image compressed:', {
          original: dataUrl.length,
          compressed: compressedDataUrl.length,
          reduction: ((1 - compressedDataUrl.length / dataUrl.length) * 100).toFixed(1) + '%'
        });
        
        callback(compressedDataUrl);
      };
      
      img.onerror = function() {
        console.error('Error loading image for compression');
        callback(dataUrl); // Fallback to original
      };
      
      img.src = dataUrl;
    }

    function removeImage() {
      const container = document.getElementById('image-preview-container');
      const loading = document.getElementById('image-loading');
      const preview = document.getElementById('preview-image');
      const galleryInput = document.getElementById('image-input');
      const cameraInput = document.getElementById('camera-input');
      
      container.style.display = 'none';
      loading.style.display = 'none';
      preview.style.display = 'block';
      preview.src = '';
      galleryInput.value = '';
      cameraInput.value = '';
      currentImage = '';
      console.log('Image removed');
      
      // Check if save button should be enabled
      checkSaveEnabled();
    }

    function toggleOptionsMenu() {
      console.log('Toggling options menu');
      const menu = document.getElementById('options-menu');
      if (!menu) {
        console.error('Options menu element not found');
        return;
      }
      
      // Ensure buttons are visible if user is signed in
      if (currentUser) {
        document.getElementById('start-journaling-btn').style.display = 'block';
        document.getElementById('past-reflections-btn').style.display = 'block';
        document.getElementById('home-btn').style.display = 'block';
        console.log('User is signed in, showing buttons');
      } else {
        document.getElementById('start-journaling-btn').style.display = 'none';
        document.getElementById('past-reflections-btn').style.display = 'none';
        document.getElementById('home-btn').style.display = 'none';
        console.log('User is not signed in, hiding buttons');
      }
      
      menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }


    function copyShareLink() {
      let userId = localStorage.getItem('sharedUserId');
      if (!userId) {
        // Generate a new user ID if none exists
        userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2);
        localStorage.setItem('sharedUserId', userId);
      }
      
      const shareUrl = `${window.location.origin}${window.location.pathname}?user=${userId}`;
      
      // Try to copy to clipboard
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(shareUrl).then(() => {
          alert('📱 Share link copied! Open this link on your other devices to sync your journals.\n\n' + shareUrl);
        }).catch(() => {
          // Fallback if clipboard fails
          prompt('Copy this link to share with your other devices:', shareUrl);
        });
      } else {
        // Fallback for older browsers
        prompt('Copy this link to share with your other devices:', shareUrl);
      }
    }















    // Initialize auth state - Firebase only
    async function initAuth() {
      // This function is no longer needed since we use Firebase auth
      // Firebase auth is handled in initFirebaseAuth()
      console.log('Using Firebase authentication only');
    }

    // Event listeners
    document.getElementById('title').addEventListener('input', checkSaveEnabled);
    document.getElementById('reflection').addEventListener('input', checkSaveEnabled);
    document.getElementById('save').addEventListener('click', saveReflection);
    // Add event listeners for both gallery and camera inputs
    document.getElementById('image-input').addEventListener('change', previewImage);
    document.getElementById('camera-input').addEventListener('change', previewImage);
    
    // Add click listeners for gallery and camera buttons
    document.querySelector('label[for="image-input"]').addEventListener('click', function(e) {
      e.preventDefault(); // Prevent default label behavior
      console.log('Photos button clicked');
      
      // Simple approach: create a clean input and trigger it
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.style.display = 'none';
      input.addEventListener('change', previewImage);
      
      // Add to DOM and trigger
      document.body.appendChild(input);
      input.click();
      
      // Clean up
      setTimeout(() => {
        if (document.body.contains(input)) {
          document.body.removeChild(input);
        }
      }, 1000);
    });
    
    document.querySelector('label[for="camera-input"]').addEventListener('click', function(e) {
      e.preventDefault(); // Prevent default label behavior
      console.log('Camera button clicked');
      
      // Ensure the camera input opens camera
      const cameraInput = document.getElementById('camera-input');
      cameraInput.setAttribute('capture', 'environment');
      
      // Trigger the camera
      cameraInput.click();
    });

    // Load reflections and initialize auth on page load
    async function initializeApp() {
      console.log('Initializing app...');
      
      // Load theme first
      loadTheme();
      
      // Try to initialize Firebase with retry
      let firebaseInitialized = false;
      for (let i = 0; i < 3; i++) {
      if (initializeFirebase()) {
          firebaseInitialized = true;
        console.log('Firebase initialized successfully');
        await initFirebaseAuth();
          break;
      } else {
          console.log(`Firebase initialization attempt ${i + 1} failed, retrying...`);
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
        }
      }
      
      if (!firebaseInitialized) {
        console.log('Firebase not configured after retries, showing auth screen');
        showAuthScreen();
      }
      
      setInterval(updateDateTime, 1000);
      updateDateTime();
      
      // Auto-retry any failed deletions
      await autoRetryFailedDeletions();
      
      // Check quota status
      checkQuotaStatus();
      
      // Check storage health
      checkStorageHealth();
    }
    
    // Initialize Firebase Auth
    async function initFirebaseAuth() {
      try {
        // Check for redirect result first (in case user just came back from redirect)
        try {
          const result = await auth.getRedirectResult();
          if (result.user) {
            console.log('User signed in via redirect:', result.user);
            // The onAuthStateChanged will handle the rest
          }
        } catch (redirectError) {
          console.log('No redirect result or error:', redirectError);
        }
        
        // Check for existing session with error handling
        auth.onAuthStateChanged((user) => {
          if (user) {
            // User is signed in
            currentUser = {
              id: user.uid,
              email: user.email,
              name: user.displayName,
              photoURL: user.photoURL,
              isFirebase: true
            };
            console.log('Firebase user signed in:', {
              uid: user.uid,
              email: user.email,
              displayName: user.displayName
            });
            
            // Simple screen change if coming from auth screen
            const authScreen = document.getElementById('auth-screen');
            if (authScreen && !authScreen.classList.contains('hidden')) {
              document.getElementById('auth-screen').classList.add('hidden');
              document.getElementById('main-screen').classList.remove('hidden');
              document.getElementById('sign-out-btn').style.display = 'block';
              loadReflections();
            } else {
            showMainScreen();
            loadReflections();
            }
          } else {
            // User is signed out
            console.log('No Firebase user signed in');
            showAuthScreen();
          }
        }, (error) => {
          console.error('Auth state change error:', error);
          // Handle sessionStorage errors gracefully
          if (error.code === 'auth/storage-unsupported' || 
              error.message.includes('sessionStorage') ||
              error.message.includes('Unable to process request') ||
              error.message.includes('missing initial state')) {
            console.log('SessionStorage issue detected, showing auth screen');
            showAuthScreen();
          }
        });
      } catch (error) {
        console.error('Firebase auth initialization error:', error);
        showAuthScreen();
      }
    }
    
    // Wait for DOM and scripts to load
    function startApp() {
      // Give a little time for scripts to load
      setTimeout(() => {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
          initializeApp();
        }
      }, 100);
    }
    
    startApp();
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(reg => console.log('Service Worker registered', reg))
          .catch(err => console.log('Service Worker registration failed', err));
      });
    }
  </script>
</body>
</html>
